#include <vector>#include <queue>#include <map>#include <string>#include <fstream>#include <windows.h>using namespace std;#include "seditcontrol.h"#include "Plugin.hpp"/****************************************************************************************************//*                                 Lang Files Encoder                                               *//****************************************************************************************************/struct LangFilesEncoder : Encoder{  static const wchar_t SPECIAL_CHARACTER = L'â™ ';  LPCWSTR GetCodingId() const  {    return L"lang";  }  LPCWSTR GetCodingName() const  {    return L"Lang file";  }  int GetControlCharacterSize() const  {    return 1;  // size of termination symbol, \n and \r symbols (for UTF-16 = 2)  }  float DetectCoding(const char *buff, int size)  {        return 0;  // never suggest this encoder  }  void DecodeString(__in const char *str, __in size_t length, __inout PluginBuffer<wchar_t> &result, __out size_t &resultLength)  {    if (result.GetBufferSize() < length + 1)      result.IncreaseBufferSize(length - result.GetBufferSize() + 1);    wchar_t *buffer = result.GetBuffer();    resultLength = MultiByteToWideChar(CP_UTF8, 0, str, length, buffer, length + 1);        for (int i = 0; i < resultLength; i++)    {      if (!buffer[i])         buffer[i] = SPECIAL_CHARACTER;    }    buffer[resultLength] = L'\0';  }  void EncodeString(__in const wchar_t *wstr, __in size_t length, __inout PluginBuffer<char> &result, __out size_t &resultLength)  {    wchar_t *copy = new wchar_t[length + 1];    for (size_t i = 0; i < length; i++)    {      if (wstr[i] == SPECIAL_CHARACTER)        copy[i] = L'\0';      else        copy[i] = wstr[i];    }    copy[length] = L'\0';    size_t requiredSize = WideCharToMultiByte(CP_UTF8, 0, copy, length, NULL, 0, NULL, NULL) + 1;    if (result.GetBufferSize() < requiredSize)      result.IncreaseBufferSize(requiredSize - result.GetBufferSize());    resultLength = requiredSize - 1;    char *buffer = result.GetBuffer();    WideCharToMultiByte(CP_UTF8, 0, copy, length, buffer, requiredSize, NULL, NULL);    buffer[resultLength] = '\0';    delete[] copy;  }  bool WriteBOM(__inout FILE *fOut)  {    unsigned char bom[3] = {0xEF, 0xBB, 0xBF};    fwrite(&bom, 3, 1, fOut);    return true;  }  bool SkipBOM(__inout FILE *fIn)  {    unsigned char bom[3] = {0xEF, 0xBB, 0xBF};    unsigned char buff[3];    if (fread(buff, 3, 1, fIn) > 0 && memcmp(buff, bom, 3) == 0)      return true;    fseek(fIn, 0, SEEK_SET);    return false;  }};/****************************************************************************************************//*                                 Plugin                                                           *//****************************************************************************************************/class LangFilesHandlerPlugin : public Plugin {private:  static LangFilesHandlerPlugin *ourPlugin;private:  PluginService *myService;  LangFilesEncoder myLangFilesEncoder;  public:  static LangFilesHandlerPlugin& GetInstance()   {    if (!ourPlugin)       ourPlugin = new LangFilesHandlerPlugin;    return *ourPlugin;  }  static void ReleaseInstance()  {    if (ourPlugin)    {      delete ourPlugin;      ourPlugin = 0;    }  }public:  LangFilesHandlerPlugin() {}    LPCWSTR GetGUID() const  {    return L"74A3CB0A-5290-11E2-ACB7-D8166188709B";  }  int GetVersion() const  {    return 1;  }  LPCWSTR GetName() const   {    return L"Lang Files Handler";  }  int GetPriority() const   {    return 0x7f;  }  bool Init(HMODULE hModule, PluginService *service)  {    myService = service;    myService->RegisterEncoder(&myLangFilesEncoder);    return true;      }  void ExecuteCommand(__in LPCWSTR name) { /* not in use */ }  void ExecuteFunction(__in LPCWSTR name, __inout void *param) { /* not in use */ }  void ExecuteMenuCommand(__in int itemId) { /* not in use */ }  int GetSupportedCommandsNumber()  {    return 0;  }  const PluginCommand* GetSupportedCommands()  {    return 0;  }  int GetSupportedFunctionsNumber()  {    return 0;  }  const LPCWSTR* GetSupportedFunctions()  {    return 0;  }  HMENU GetMenuHandle(int firstItemId)  {    return 0;  }  int GetMenuItemsNumber()  {    return 0;  }  void ProcessNotification(const PluginNotification *notification) { /* not in use */ }   ~LangFilesHandlerPlugin()  {    myService->UnregisterEncoder(myLangFilesEncoder.GetCodingId());  }private:  bool handleError()  {    if (myService->GetLastError() != NO_ERROR)    {      VectorPluginBuffer<wchar_t> buffer;      myService->GetLastErrorMessage(&buffer);      myService->ShowError(buffer.GetBuffer());      return true;    }    return false;  }  };/****************************************************************************************************//*                                 External functions                                               *//****************************************************************************************************/extern "C"Plugin* __stdcall SECreatePlugin(){  return &LangFilesHandlerPlugin::GetInstance();}extern "C"void __stdcall SEDeletePlugin(Plugin *plugin){  LangFilesHandlerPlugin::ReleaseInstance();}/****************************************************************************************************//*                                 Static initialization                                            *//****************************************************************************************************/LangFilesHandlerPlugin* LangFilesHandlerPlugin::ourPlugin(0);