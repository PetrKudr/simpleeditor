/* ==========================================================================
   Описание: библиотека для автоматического определения кодировки текста
   Описание алгоритма: http://ivr.webzone.ru/articles/defcod_2/
   (c) Иван Рощин, Москва, 2004.
 ========================================================================= */

#include <stdio.h>
#include "adbytecp.h"

/* Таблица сочетаний */

static unsigned char table_2s[128]={0xFF,0xFF,0xFF,0xC7,0xFE,0xBE,0xF7,0xFB,
 0xFD,0xBF,0xF7,0xF9,0xFC,0xBE,0xF1,0x80,0xFF,0xFF,0xF7,0xBB,0xFF,0xFF,0xFF,
 0xCF,0xDE,0xBF,0xD1,0x08,0xFF,0xBF,0xF1,0xBF,0xFF,0xFF,0xFF,0xC7,0x1D,0x3F,
 0x7F,0x81,0xA7,0xB6,0xF2,0x82,0xFF,0xFF,0x75,0xDB,0xFC,0xBF,0xD7,0x9D,0xFF,
 0xAE,0xFB,0xDF,0xFF,0xFF,0xFF,0xC7,0x84,0xB7,0xF3,0x9F,0xFF,0xFF,0xFF,0xDB,
 0xFF,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC7,0x84,0x9E,0xF0,
 0x12,0xBC,0xBF,0xF0,0x84,0xA4,0xBA,0x10,0x10,0xA4,0xBE,0xB8,0x88,0xAC,0xBF,
 0xF7,0x0A,0x84,0x86,0x90,0x08,0x04,0x00,0x00,0x03,0x7F,0xFD,0xF7,0xC1,0x7D,
 0xAE,0x6F,0xCB,0x15,0x3D,0xFC,0x00,0x7F,0x7D,0xE7,0xC2,0x7F,0xFD,0xF7,0xC3};

/* =========================================================================
   Вспомогательная функция alt2num.
   Вход: a - код русской буквы в кодировке ALT.
   Выход: порядковый номер этой буквы (0-31).
 ========================================================================= */

static int alt2num (int a)
{
 if (a>=0xE0) a-=0x30;
 return (a&31);
}

/* =========================================================================
   Вспомогательная функция koi2num.
   Вход: a - код русской буквы в кодировке KOI.
   Выход: порядковый номер этой буквы (0-31).
 ========================================================================= */

static int koi2num (int a)
{
 static unsigned char t[32]={30,0,1,22,4,5,20,3,21,8,9,10,11,12,13,14,15,31,
  16,17,18,19,6,2,28,27,7,24,29,25,23,26};

 return (t[a&31]);
}

/* =========================================================================
   Вспомогательная функция work_2s - обработка двухбуквенного сочетания.
   Вход:  с1 - порядковый номер первой буквы (0-31),
          c2 - порядковый номер второй буквы (0-31),
          check - надо ли проверять, встречалось ли сочетание раньше
                  (1 - да, 0 - нет),
          buf - адрес массива с информацией о встреченных сочетаниях.
   Выход: 0 - указанное сочетание уже встречалось раньше,
          1 - сочетание не встречалось раньше и является допустимым,
          2 - сочетание не встречалось раньше и является недопустимым.
 ========================================================================= */

static int work_2s (int c1, int c2, int check, unsigned char buf[128])
{
 int i=(c1<<2)+(c2>>3); /* Номер байта в массиве. */
 int mask=0x80>>(c2&7); /* Маска, соответствующая номеру бита в байте. */

 /* Если check=1, проверяем: если соответствующий бит массива buf равен 0,
    значит, указанное сочетание уже встречалось раньше. Тогда выходим из
    функции, возвращая 0. Если же сочетание не встречалось, то помечаем, что
    оно встретилось (обнуляем соответствующий бит массива buf). */

 if (check==1)
 {
  if ((buf[i]&mask)==0) return (0);
  buf[i]&=~mask;
 }

 /* Проверяем, допустимо сочетание или нет. */

 if ((table_2s[i]&mask)!=0) return (1); /* Допустимо. */
 return (2);                            /* Недопустимо. */
}

/* =========================================================================
   Вспомогательная функция m_get_char вызывается из функции def_code, когда
   та вызвана из m_def_code.
   Выход: очередной символ текста или -1, если текст кончился.
 ========================================================================= */

#define get_char(p, len)  ((len) == 0 ? -1 : *(p++)) 

/* =========================================================================
   Вспомогательная функция def_code - определение кодировки текста.
   Вход:  n - количество различных сочетаний русских букв (1-255), которого
              достаточно для определения кодировки.
   Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI, 3 - неудалось определить.
 ========================================================================= */

static int def_code (int n, const unsigned char *p, int len)
{
 /* В массиве buf_1 хранится информация о том, какие сочетания руских букв
    уже встречались в варианте ALT, а в массиве buf_2 - в варианте WIN. */

 unsigned char buf_1 [128];
 unsigned char buf_2 [128];

 int bad_1=0;
 int bad_2=0;
 int bad_3=0;
 int all_1=0;
 int all_3=0;  /* all_2=all_3 */

 int c1; int c2=0; /* Символы текущего обрабатываемого сочетания. */
 int i;

 /* Инициализация buf_1 и buf_2. */

 for (i=0;i<128;i++) buf_1[i]=0xFF;
 for (i=0;i<128;i++) buf_2[i]=0xFF;

 /* Главный цикл - обработка сочетаний для каждого из трёх вариантов. Цикл
    выполняется, пока не кончится текст или в каком-либо из вариантов не
    встретится n сочетаний. */

 while (((c1=c2,c2=get_char(p, len))!=-1)&&(all_1<n)&&(all_3<n))
 {
   --len;

  /* Вариант ALT. Вначале проверяем, являются ли символы текущего сочетания
     кодами русских букв в кодировке ALT. */

  if ((((c1>=0x80)&&(c1<0xB0))||((c1>=0xE0)&&(c1<0xF0)))&&
      (((c2>=0x80)&&(c2<0xB0))||((c2>=0xE0)&&(c2<0xF0))))
  {
   switch (work_2s(alt2num(c1),alt2num(c2),1,buf_1)) /* Обработали. */
   {
    case 2: bad_1++;
    case 1: all_1++;
   }
  }
  /* Варианты WIN и KOI. Вначале проверяем, являются ли символы текущего
     сочетания кодами русских букв в этих кодировках (в обеих кодировках
     диапазоны кодов русских букв совпадают). */

  if ((c1&c2)>=0xC0) /* Эквивалентно условию (c1>=0xC0)&&(c2>=0xC0). */
  {
   switch (work_2s(c1&31,c2&31,1,buf_2)) /* Обработали. */
   {
    case 0: continue; /* Если сочетание букв уже встречалось в варианте WIN,
                         то оно уже встречалось и в варианте KOI, так что
                         пропускаем обработку варианта KOI и переходим
                         к следующей итерации главного цикла. */
    case 2: bad_2++;
   }

  /* Если сочетание букв ещё не встречалось в варианте WIN, то оно заведомо
     не встречалось и в варианте KOI, поэтому специально проверять это не
     надо - значит, функцию work_2s вызываем с параметром check, равным 0. */

   switch (work_2s(koi2num(c1),koi2num(c2),0,NULL)) /* Обработали. */
   {
    case 2: bad_3++;
    case 1: all_3++;
   }
  }
 }

 /* Данные собраны. Теперь, если в каком-либо из вариантов недопустимых
    сочетаний не больше 1/32 от общего их числа, то считаем, что их и не
    было. */

 if (bad_1<=(all_1>>5)) bad_1=0;
 if (bad_2<=(all_3>>5)) bad_2=0;
 if (bad_3<=(all_3>>5)) bad_3=0;

 if ((all_1 | all_3) == 0)
   return 3;
 if ((bad_1>(all_1>>4)) && (bad_3>(all_3>>4)) && (bad_3>(all_3>>4)))
   return 3;  // ANSI

 /* Получаем результат. */

 {
  unsigned int a=((255-bad_1)<<8)+all_1;
  unsigned int b=((255-bad_2)<<8)+all_3;
  unsigned int c=((255-bad_3)<<8)+all_3;

  if ((a>=b)&&(a>=c)) return (0);
  if (b>=c) return (1); else return (2);
 }
}

/* =========================================================================
   Функция m_def_code - определение кодировки текста, находящегося в памяти.
   Вход:  p - адрес текста,
          len - длина текста,
          n - количество различных сочетаний русских букв (1-255), которого
              достаточно для определения кодировки.
   Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI, 3 - неудалось определить.
 ========================================================================= */

extern int m_def_code (const unsigned char *p, int len, int n)
{
 /* Получаем результат. */
 return (def_code(n, p, len));
}